{
    "componentChunkName": "component---src-templates-md-blog-post-js",
    "path": "/posts/2025-04-07-plaid-ctf-2025-tales-from-the-crypt",
    "result": {"data":{"markdownRemark":{"html":"<p>This is a writeup of Tales from the Crypt from Plaid CTF 2025. I solved it\nalongside a few team mates from Blue Water, and we were the first of three\nsolvers of the challenge. We also won the CTF :) Thanks to PPP for hosting!</p>\n<p>In my timezone(s), the CTF ran from Saturday 8AM until Monday 7AM. I started\nlooking at this challenge at around noon on Saturday and continued to work in\nit (of course with breaks to eat and sleep as you should) until we got the flag\nat around 2PM on the Sunday. It was a fairly involved challenge and <em>probably</em>\nshould have been tagged with \"misc\" as well as crypto. Notably, the challenge\ndid involve reading openssl source code, knowing some facts about TLS and using\nWireshark, but I think this is fair scope for a crypto challenge (after all,\nopenssl and TLS are probably the most ubiquitous crypto-like things in the real\nworld). Ultimately, it tasked players with exploiting a cryptographic\nvulnerability - one that was \"inserted\" into the challenge and appeared as a\nfairly trivially exploitable issue on its own - in a somewhat realistic setup\nwhich with came details that ended up making exploitation not as trivial as it\nmay have seemed from a first glance.</p>\n<p>This writeup will be more expository than detailing the exact implementation of\nour solution. An overview of the challenge is included so you can still read\nand understand everything without leaving the page. Assuming you played the\nchallenge or already know the setup, feel free to skip straight to the\n<a href=\"#solution\">Solution</a>.</p>\n<h1>Challenge Overview</h1>\n<blockquote>\n<p>Legends tell of an ancient cowpoke who once stole a secret and locked it up tight. Pry the secret from the spirit's grasp and set him free. Hint: The author solution takes approximately one hour on a laptop.</p>\n<p>Posted by Sheriff b2xiao</p>\n<p>With Deputy tjbecker</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> ubuntu@sha256:aa772c98400ef833586d1d517d3e8de670f7e712bf581ce6053165081773259d</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> DEBIAN_FRONTEND=noninteractive</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> apt-get update &amp;&amp; apt-get install -yq python3 python3-pip openssl &amp;&amp; rm -rf /var/lib/apt/lists/*</span>\n\n<span class=\"token comment\"># This next line creates a key, only for local testing</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes -subj <span class=\"token string\">\"/C=US/ST=PA/L=Ashwood Hollow/CN=tales-from-the-crypt.chal.pwni.ng\"</span></span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./requirements.txt /</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> pip3 install -r requirements.txt</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./server.py /</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./util.py /</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./key.pem /</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> ./cert.pem /</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 1337</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">CMD</span> [<span class=\"token string\">\"python3\"</span>, <span class=\"token string\">\"server.py\"</span>]</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token comment\"># server.py</span>\n\n<span class=\"token keyword\">import</span> time\n<span class=\"token keyword\">from</span> http<span class=\"token punctuation\">.</span>server <span class=\"token keyword\">import</span> BaseHTTPRequestHandler<span class=\"token punctuation\">,</span> ThreadingHTTPServer\n\n<span class=\"token keyword\">from</span> util <span class=\"token keyword\">import</span> make_ssl_connection\n\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyHTTPSRequestHandler</span><span class=\"token punctuation\">(</span>BaseHTTPRequestHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">def</span> <span class=\"token function\">setup</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        self<span class=\"token punctuation\">.</span>request <span class=\"token operator\">=</span> make_ssl_connection<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>request<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> <span class=\"token builtin\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>setup<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">def</span> <span class=\"token function\">do_GET</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        match self<span class=\"token punctuation\">.</span>path<span class=\"token punctuation\">:</span>\n            case <span class=\"token string\">\"/\"</span><span class=\"token punctuation\">:</span>\n                status <span class=\"token operator\">=</span> <span class=\"token number\">200</span>\n                content <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">\"\"\"\n&lt;p>I think my server is haunted.&lt;/p>\n&lt;p>&lt;a href=\"/flag\">Get flag&lt;/a>&lt;/p>\n&lt;p>&lt;a href=\"/time\">Get current server time&lt;/a>&lt;/p>\n\"\"\"</span>\n            case <span class=\"token string\">\"/flag\"</span><span class=\"token punctuation\">:</span>\n                status <span class=\"token operator\">=</span> <span class=\"token number\">404</span>\n                content <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">\"\"\"\n&lt;p>ðŸ‘»ðŸ‘»ðŸ‘» My flag seems to have been stolen by ghosts...! ðŸ‘»ðŸ‘»ðŸ‘»&lt;/p>\n\"\"\"</span>\n            case <span class=\"token string\">\"/time\"</span><span class=\"token punctuation\">:</span>\n                status <span class=\"token operator\">=</span> <span class=\"token number\">200</span>\n                content <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"\"\"\n&lt;p>Current time: </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>time<span class=\"token punctuation\">.</span>ctime<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token string\">&lt;/p>\n\"\"\"</span></span>\n            case _<span class=\"token punctuation\">:</span>\n                status <span class=\"token operator\">=</span> <span class=\"token number\">404</span>\n                content <span class=\"token operator\">=</span> <span class=\"token triple-quoted-string string\">\"\"\"\n&lt;h1>404 Not Found&lt;/h1>\n\"\"\"</span>\n\n        raw_content <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"\"\"&lt;!DOCTYPE html>\n&lt;html>\n&lt;body></span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>content<span class=\"token punctuation\">}</span></span><span class=\"token string\">&lt;/body>\n&lt;/html>\"\"\"</span></span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span>\n            <span class=\"token string\">\"utf-8\"</span>\n        <span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>send_response<span class=\"token punctuation\">(</span>status<span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>send_header<span class=\"token punctuation\">(</span><span class=\"token string\">\"Content-Type\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"text/html; charset=utf8\"</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>send_header<span class=\"token punctuation\">(</span><span class=\"token string\">\"Content-Length\"</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>raw_content<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>end_headers<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>wfile<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span>raw_content<span class=\"token punctuation\">)</span>\n\n\nhttpd <span class=\"token operator\">=</span> ThreadingHTTPServer<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1337</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> MyHTTPSRequestHandler<span class=\"token punctuation\">)</span>\nhttpd<span class=\"token punctuation\">.</span>serve_forever<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\"><span class=\"token comment\"># util.py</span>\n\n<span class=\"token keyword\">from</span> socket <span class=\"token keyword\">import</span> socket\n<span class=\"token keyword\">from</span> secrets <span class=\"token keyword\">import</span> randbits\n<span class=\"token keyword\">from</span> select <span class=\"token keyword\">import</span> select\n\n<span class=\"token keyword\">from</span> Crypto<span class=\"token punctuation\">.</span>PublicKey <span class=\"token keyword\">import</span> RSA\n<span class=\"token keyword\">from</span> OpenSSL <span class=\"token keyword\">import</span> SSL<span class=\"token punctuation\">,</span> crypto\n\n<span class=\"token comment\"># generated with `openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -sha256 -days 3650 -nodes`</span>\nkey <span class=\"token operator\">=</span> RSA<span class=\"token punctuation\">.</span>import_key<span class=\"token punctuation\">(</span><span class=\"token builtin\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"key.pem\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"rb\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>read<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\np <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">.</span>n<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span>e<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span>d<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span>p<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span>q<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">.</span>u<span class=\"token punctuation\">]</span>\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">ctx_with_key</span><span class=\"token punctuation\">(</span>certpath<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span><span class=\"token punctuation\">,</span> keyp<span class=\"token punctuation\">:</span> <span class=\"token builtin\">list</span><span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> SSL<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">:</span>\n    ctx <span class=\"token operator\">=</span> SSL<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">(</span>SSL<span class=\"token punctuation\">.</span>SSLv23_METHOD<span class=\"token punctuation\">)</span>\n    ctx<span class=\"token punctuation\">.</span>set_options<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token operator\">&lt;&lt;</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span>\n    ctx<span class=\"token punctuation\">.</span>use_certificate_file<span class=\"token punctuation\">(</span>certpath<span class=\"token punctuation\">)</span>\n    key <span class=\"token operator\">=</span> RSA<span class=\"token punctuation\">.</span>construct<span class=\"token punctuation\">(</span>keyp<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>exportKey<span class=\"token punctuation\">(</span>pkcs<span class=\"token operator\">=</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span>\n    ctx<span class=\"token punctuation\">.</span>use_privatekey<span class=\"token punctuation\">(</span>crypto<span class=\"token punctuation\">.</span>load_privatekey<span class=\"token punctuation\">(</span>crypto<span class=\"token punctuation\">.</span>FILETYPE_PEM<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> ctx\n\ndefault_ctx <span class=\"token operator\">=</span> ctx_with_key<span class=\"token punctuation\">(</span><span class=\"token string\">\"cert.pem\"</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_ctx</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> SSL<span class=\"token punctuation\">.</span>Context<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> select<span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span>sock<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>sock<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>sock<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0.2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n        <span class=\"token punctuation\">[</span>k<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> sock<span class=\"token punctuation\">.</span>recv<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">return</span> ctx_with_key<span class=\"token punctuation\">(</span><span class=\"token string\">\"cert.pem\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token punctuation\">:</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">^</span> <span class=\"token punctuation\">(</span>randbits<span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;&lt;</span> <span class=\"token number\">3</span> <span class=\"token operator\">*</span> k<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>p<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> default_ctx\n\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">make_ssl_connection</span><span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">:</span> socket<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> SSL<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">:</span>\n    conn <span class=\"token operator\">=</span> SSL<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">(</span>get_ctx<span class=\"token punctuation\">(</span>sock<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> sock<span class=\"token punctuation\">)</span>\n    conn<span class=\"token punctuation\">.</span>set_accept_state<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> conn\n\n\nSSL<span class=\"token punctuation\">.</span>Connection<span class=\"token punctuation\">.</span>makefile <span class=\"token operator\">=</span> socket<span class=\"token punctuation\">.</span>makefile</code></pre></div>\n<p>We are given the above files, along with a <code>capture.pcap</code> file and a live\nserver to interact with. The server is a HTTPS server which has a <code>/flag</code> and a\n<code>/time</code> endpoint, although the <code>/flag</code> endpoint doesn't actually give anything\nthat resembles a flag. Going based on the description of the challenge, the\n<code>/flag</code> endpoint maybe previously did give the flag, but doesn't anymore. This\nis likely where the packet capture file comes in - it could contain a capture\nof a HTTP request to <code>/flag</code> and its response containing the actual flag. The\nonly issue is that the server uses TLS, so we can't just read it...</p>\n<p>The way the server handles TLS connections is interesting - it uses openssl\nthrough Python bindings to handle everything which is normal, but in <code>get_ctx</code>\nwe can see that it seems to conditionally perform some corruption on its\nprivate key on an incoming connection. Ignoring all the context, this is a\nfairly simple RSA vulnerability with simple exploitation, but if it really was\nthat simple, it probably wouldn't be the least solved challenge in a Plaid CTF\n(zerodeo doesn't count). But at this point, at least the path to getting the\nflag is clear: recover the server's RSA private key. So how do you do it?</p>\n<h1>Solution <a name=\"solution\"></a></h1>\n<p>This is the high level summary of how we solved it:</p>\n<ol>\n<li>A pcap file is given containing TLS traffic to the challenge server (<code>tcp.stream eq 72</code>/<code>tcp.stream eq 74</code>). Observing the TLS handshake, we can see that the client key exchange is performed with \"RSA Encrypted PreMaster Secret\", so having the server's RSA private key would allow the session traffic to be decrypted. Stream 74 is the one with a request to <code>/flag</code> and contains the flag in the response. Obviously, we don't know this at the start, but its a fairly reasonable assumption to make about the challenge (since we can see that its using the server's RSA key to encrypt the PreMaster Secret).</li>\n<li>Sending the first byte (<code>k</code>) over the TCP connection with the <code>MSG_OOB</code> flag set can be used to trigger the private key bit flipping corruption \"feature\".</li>\n<li>Suppose for simplicity, you sent <code>k = 0</code>, and the <code>randbits(3)</code> call returns <code>1</code>. The LSB of <code>d</code> will be flipped. Suppose the LSB of <code>d</code> is <code>1</code>, this means <code>d_faulty = d - 1</code> will be used in the TLS operations. If a message <code>m</code> is signed with this, and we know the message and the resulting signature <code>s = m^d_faulty (mod N)</code>, then we could distinguish that the LSB of <code>d</code> was indeed <code>1</code> by checking if <code>(s * m)^e == m (mod N)</code>. This generalises to all bits reachable by ranging <code>k</code> between <code>0</code> and <code>255</code>. This can theoretically be used to recover the bottom 768 bits of <code>d</code>.</li>\n<li>Noting that the RSA key is 2048 bits, we can use the well-known technique described in <a href=\"https://cic.iacr.org/p/1/1/28/pdf\">\"Survey: Recovering cryptographic keys from partial information, by example\"</a> (section 4.2.9.) to find candidates for the lower 768 bits of <code>p</code> and then ultimately recover the RSA private key.</li>\n<li>With the RSA private key, we can simply import it into Wireshark to decrypt the mentioned TLS traffic and read the flag in the HTTP response.</li>\n</ol>\n<p>Now for the actual details, because I'm sure you already knew most of that:</p>\n<h2>Steps 1 and 2</h2>\n<p>Step 1 and step 2 are fine as is, and apart from having to install/open\nWireshark and read a man page, it shouldn't be anything insurmountable for a\ncrypto player.</p>\n<h2>Fixing Step 3</h2>\n<p>Step 3 works in theory, but requires a few things: firstly that you know the\nmessage being signed by the server, and secondly that the server really does\njust compute <code>s = m^d (mod N)</code>. The first one can be dealt with by using TLS\n1.2 and PKCS#1 v1.5, instead of the \"default\" (depending on how you were\ninteracting with the server) TLS 1.3 with RSA-PSS (which includes randomness in\nthe value <code>m</code> that you don't get to know as the client).</p>\n<p>Secondly, the server doesn't actually just compute <code>s = m^d (mod N)</code>. This is\nwhere the openssl perusing part of the challenge comes. To condense a few hours\nof reading source code, debugging openssl and pain into a few sentences:\n<a href=\"https://github.com/openssl/openssl/blob/openssl-3.4/crypto/rsa/rsa_ossl.c#L304\"><code>rsa_ossl_private_encrypt</code></a>\ndefines the function that is called when the server signs the message. Notably\nit performs \"blinding\" on the message before performing the modular\nexponentiation. The way it does this is by choosing a random blinding parameter\n<code>A</code> and computing the blinded signature <code>blinded_s = (m A^e)^d (mod N)</code>.\n<em>Obviously</em>, since <code>A^(ed) = 1 (mod N)</code>, this becomes <code>blinded_s = m^d A (mod N)</code>. The blinding is then removed to obtain the actual signature <code>s = blinded_s A^-1 (mod N) = m^d (mod N)</code>. Wait a sec, isn't this just <code>s = m^d (mod N)</code>?\nWell yes, but actually no - I wasn't lying when I said the server doesn't\nactually just compute <code>s = m^d (mod N)</code>. It doesn't. It computes <code>s = (m A^e)^d A^-1 (mod N)</code>. When <code>ed = 1 (mod phi(N))</code>, then we do end up with <code>s = m^d (mod N)</code>. But this isn't the case when <code>d</code> is corrupted and the aforementioned\nrelationship with <code>e</code> ceases to hold.</p>\n<p>Of course, we didn't just decide to read the code for this particular function\nand notice that the signatures were being blinded. I foolishly had started\nimplementing a solution (following the assumption exactly as in step 3) to\nrecover the bits, hacking together a patched version of\n<a href=\"https://github.com/tlsfuzzer/tlslite-ng\"><code>tlslite-ng</code></a> to introspect the TLS\nmessages being sent between us and the server. It wasn't until after realising\nthat something wasn't adding up did we decide to more properly understand what\nwas going on. Anyway, after going from not understanding why the attack isn't\nworking to realising it's because of the blinding, we were back to being stuck,\nbut at least it was progress.</p>\n<p>So the signatures we were getting from the server were not <code>s = m^d_faulty (mod N)</code> as we had originally thought and hoped for, they were <code>s = (m A^e)^d_faulty A^-1 (mod N)</code>. Noting that <code>A</code> is a random blinding parameter (securely)\ngenerated on the server and therefore an unknown value, our previous attack to\nrecover bits in <code>d</code> no longer applies. It's sad - I thought we were on to\nsomething but it ended up making things harder! Then again, it was reaching\nT+12h into the CTF and if it was that easy it probably would have been solved\nby then. So can we adjust the attack to work with this unknown blinding factor?\nI would guess probably not, so it was time to look for other ways to make\nprogress.</p>\n<p>In the challenge (<code>util.py</code>), the server creates an <code>SSL.Context</code> with the\ncorrupted key (assuming an <code>MSG_OOB</code> byte was sent) on receiving an incoming\nconnection . This sets up the openssl objects including the RSA private key,\nthe lifetime of which spans the entire connection. This becomes relevant upon\nnoticing that the blinding parameters are created per RSA key and stored\nalongside the key itself, as seen in\n<a href=\"https://github.com/openssl/openssl/blob/openssl-3.4/crypto/rsa/rsa_ossl.c#L210-L262\"><code>rsa_get_binding</code></a>.\nWhen the blinding is actually performed (in\n<a href=\"https://github.com/openssl/openssl/blob/master/crypto/bn/bn_blind.c#L132-L158\"><code>BN_BLINDING_convert_ex</code></a>),\nit would conditionally update the blinding parameters through a call to\n<a href=\"https://github.com/openssl/openssl/blob/master/crypto/bn/bn_blind.c#L91-L125\"><code>BN_BLINDING_update</code></a>.\nThis would essentially update the blinding factor <code>A</code> to be <code>A^2</code> instead.\nThis realisation begged the question: can we perform multiple handshakes in a\nsingle connection? The answer was yes, thanks to TLS renegotiation, and it was\nas easy to do as running</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">openssl s_client -connect tales-from-the-crypt.chal.pwni.ng:1337 -tls1_2 -msg -sigalgs rsa_pkcs1_sha256</code></pre></div>\n<p>and typing <code>R</code> and pressing enter.</p>\n<p>At this point, adapting the attack as described in step 3 was possible! We\nsimply get two faulted signatures from performing the renegotiation (note that\nthey'll use the same faulted <code>d</code> and will have related blinding factors):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">s1 = (m1 A^e)^d_faulty A^-1 (mod N)\ns2 = (m2 A^(2e))^d_faulty A^-2 (mod N)</code></pre></div>\n<p>and from these, compute</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">m = m1^2 / m2 (mod N)\ns = s1^2 / s2 (mod N)</code></pre></div>\n<p>to get rid of the unknown <code>A</code> value and apply the attack to the pair <code>(m, s)</code>\nsince now <code>s = m^d_faulty (mod N)</code> truly holds.</p>\n<p>This was more or less it for fixing up step 3, modulo implementation details.</p>\n<h2>Fixing Step 4</h2>\n<p>So, we've got the lower 768 bits of <code>d</code>, call it <code>d0</code>. We're out of the misc part of the\nchallenge - no more dealing with openssl shenanigans, and can treat it like a\nnormal crypto challenge. All we need to do now is follow section 4.2.9 of\n<a href=\"https://cic.iacr.org/p/1/1/28/pdf\">\"Survey: Recovering cryptographic keys from partial information, by\nexample\"</a> and we should recover the private\nkey fully. To summarise it, we use the LSB of <code>d</code> in the relation <code>ed = 1 (mod phi(N))</code> to recover candidates for the bottom 768 bits of <code>p</code>. This works\nbecause <code>ed = 1 + k(p-1)(q-1)</code> for an integer <code>k</code> smaller than <code>e = 0x10001</code>\nwhich can be enumerated over, and so <code>ed0 = 1 + k(p-1)(q-1) (mod 2^768)</code>.\nCombining this relation with <code>N = pq (mod 2^768)</code> gives two equations on <code>p</code>\nand <code>q</code> which we can transform into a quadratic in <code>p</code> modulo <code>2^768</code>. Simply\nsolve this to recover the candidate for the lower bits of <code>p</code> and apply\nCoppersmith's method to recover <code>p</code> fully. This attack has been seen before in\nCTFs, so should be fairly straightforward.</p>\n<p>Wait then why is the section heading called \"fixing step 4\"? Well, mostly\nbecause we tried this, naively following the paper, and it failed. Though, it\nonly requires a small adaptation to fix.</p>\n<p>The equations described in the paper assume that <code>ed = 1 (mod (p-1)(q-1))</code>,\nchecking this against the keys generated as in the challenge, we find that this\nequation doesn't actually hold:</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">sage<span class=\"token punctuation\">:</span> e <span class=\"token operator\">*</span> d <span class=\"token operator\">%</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>p <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>q <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>\n<span class=\"token boolean\">False</span></code></pre></div>\n<p>Instead, we find that</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">sage<span class=\"token punctuation\">:</span> e <span class=\"token operator\">*</span> d <span class=\"token operator\">%</span> lcm<span class=\"token punctuation\">(</span>p <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> q <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">1</span>\n<span class=\"token boolean\">True</span></code></pre></div>\n<p>which is not too surprising and usually doesn't matter. But in this case it\nkind of does. Since <code>ed != 1 + k(p-1)(q-1)</code>, we can't necessarily write <code>ed0 = 1 + k(N - (p + q) + 1) (mod 2^768)</code> like in the paper. Instead, we must write\n<code>ed0 = 1 + k(p-1)(q-1)/g (mod 2^768)</code> where <code>g = gcd(p - 1, q - 1)</code>. If it\nturns out that <code>g</code> divides <code>k</code>, then the attack as described in the paper\nshould work as is. This isn't the case with the challenge parameters\nunfortunately. Fortunately, our first try of <code>g = 2</code> worked on the challenge\nparameters, and after running the solver for a few minutes, we had recovered\nthe primes of the server's RSA key.</p>\n<h2>Step 5</h2>\n<p><span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; \">\n      <a class=\"gatsby-resp-image-link\" href=\"/static/9f9ad41887bcc47be85b8f1e7f9d4f50/21482/flag.png\" style=\"display: block\" target=\"_blank\" rel=\"noopener\">\n    <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 57.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAACEUlEQVQoz2WLWW+bQACE+f9vqdqkUmU7ifIL+tQkdtwmNsEHh2HZ5VqW3YU1hwlg7EQ5FCqrVVW1o9HoG41GcsMQM24ix4simgjdAk6AQx4neYECrKia7flJllOxNgD0QqKalg5sJlLXERJOyERTALanuhKlkYXtJdJNH2x2RbgmKjJ01yRplDUpitxyv4HENTwLBCiMK+niNukP8dl33h/i87v16Zj2R+Hghp5Piv6Y9YZhb4gH4/jsNu3fRL1xcnpDB6Po5Js3UolkE244gY58G9MFdC0/1J1gZsKJbi2ht7CQCl3FhAcbYKJbKxdDwgGmIhZSlmeyulwhaLqOAW3Ntg7soBWyNWDpEJjugQ0IFENDYYBjhjkLGA3iWOJN9RXZl4F3GfiXgX9NAqXI5Ty7zzM5S6epmG3yaSpuYzYrC7V+0JpKqyt1W9vtVvKoWBhAM5FmOSvoyQvDI7EXxYSnXiQsL/JZijBHIQ94Jso2KRqxaZJNI4pa+jwhH0fw6Mo6ugYfhrB3z87m/HQeD+b8i8KOZXY8pScyO5HZ8YR+uiO/fPQjvJhRyV63Y8O9moMlKbSo0Gmp041OyxWvDFoarFyxBy06TH+qyR+spHFEJXVdV+R5zNnjfvf68rzftW3TtNvtAX5nU1dVXVXbpt7v2qfH/fPTU9d1b29vh3PTNGVZvr+/d3/pn/q/Xl5ffwIi4zWFaXI+cgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"flag\" title=\"flag\" src=\"/static/9f9ad41887bcc47be85b8f1e7f9d4f50/0a47e/flag.png\" srcset=\"/static/9f9ad41887bcc47be85b8f1e7f9d4f50/8a4e8/flag.png 150w,\n/static/9f9ad41887bcc47be85b8f1e7f9d4f50/5a46d/flag.png 300w,\n/static/9f9ad41887bcc47be85b8f1e7f9d4f50/0a47e/flag.png 600w,\n/static/9f9ad41887bcc47be85b8f1e7f9d4f50/1cfc2/flag.png 900w,\n/static/9f9ad41887bcc47be85b8f1e7f9d4f50/c1b63/flag.png 1200w,\n/static/9f9ad41887bcc47be85b8f1e7f9d4f50/21482/flag.png 1350w\" sizes=\"(max-width: 600px) 100vw, 600px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n  </a>\n    </span></img></p>","frontmatter":{"date":"April 07, 2025","path":"/posts/2025-04-07-plaid-ctf-2025-tales-from-the-crypt","title":"Plaid CTF 2025 - Tales from the Crypt","tags":"ctf,writeup,crypto"}}},"pageContext":{"prev":{"fileAbsolutePath":"/home/joseph/stuff/code/portfolio/src/posts/2024-10-03-bsidescbr-2024-ctf-forged-in-fire/index.md","frontmatter":{"title":"BSidesCbr 2024 CTF - Forged in Fire","date":"2024-10-03T00:00:00.000Z","path":"/posts/2024-10-03-bsidescbr-2024-ctf-forged-in-fire"}},"next":null}},
    "staticQueryHashes": ["4146750380"]}